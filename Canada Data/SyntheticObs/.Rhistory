#setwd("c:/Users/Tracey and Aaron/Dropbox/Field Paper/New Zealand Data/Merge/")
setwd("~/Dropbox/Field Paper/New Zealand Data/Merge/")
logitCoeffToPredictedProb = function(logitCoefs, values)
{
sum = sum(logitCoefs*values)
expValue = exp(sum)
return(expValue / (1+expValue))
}
############## PREP DATA #############
# Read the election data
dt = read.csv("output.csv", header=TRUE)
stopifnot(nrow(dt)==10267) # Replication, verify all rows loaded exactly
# Code party in government
dt$PartyInGovt = 0
dt[as.character(dt$Date)>="1940-04-01" & as.character(dt$Date)<="1949-12-12" & dt$Party=="Labour",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1949-12-13" & as.character(dt$Date)<="1957-12-11" & dt$Party=="National",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1957-12-12" & as.character(dt$Date)<="1960-12-11" & dt$Party=="Labour",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1960-12-12" & as.character(dt$Date)<="1972-12-07" & dt$Party=="National",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1972-12-08" & as.character(dt$Date)<="1975-12-12" & dt$Party=="Labour",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1975-12-13" & as.character(dt$Date)<="1984-07-26" & dt$Party=="National",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1984-07-26" & as.character(dt$Date)<="1990-11-01" & dt$Party=="Labour",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1990-11-02" & as.character(dt$Date)<="1996-11-12" & dt$Party=="National",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1996-11-13" & as.character(dt$Date)<="1999-12-04" & (dt$Party=="National" | dt$Party=="NZF"),]$PartyInGovt = 1
dt[as.character(dt$Date)>="1999-12-05" & as.character(dt$Date)<="2008-11-18" & (dt$Party=="Labour" | dt$Party=="Alliance"),]$PartyInGovt = 1
dt[as.character(dt$Date)>="2008-11-19" & dt$Party=="National",]$PartyInGovt = 1
table(dt$PartyInGovt)
# Calculate vote percentage
dt = dt %>% group_by(Date, Electorate) %>% summarise(totalVotes=sum(Votes)) %>% merge(dt,.) %>% mutate(VotePct = round(100*Votes/totalVotes,2))
# Calculate lagged vote percentage (we'll lose some obs for incumbents who came in in 1946 because we don't have 1943 vote data!)
dt = dt %>% mutate(LastVotePct = lag(VotePct, order_by=ID))
# Pull list of parties who have elected people
dt %>% group_by(Party) %>% tally(Elected, sort=TRUE)
# Recode never elected parties into independents
dt %>% group_by(Party) %>% tally(sort=TRUE)
nrow(dt[dt$Party!="National" & dt$Party!="Labour" & dt$Party!="Maori" & dt$Party!="NZF" & dt$Party!="Social Credit" & dt$Party!="UFNZ" & dt$Party!="United New Zealand" & dt$Party!="ACT" & dt$Party!="Alliance" & dt$Party!="Progressive" & dt$Party!="Mana" & dt$Party!="GP" & dt$Party!="NL" & dt$Party!="United NZ",])
dt[dt$Party!="National" & dt$Party!="Labour" & dt$Party!="Maori" & dt$Party!="NZF" & dt$Party!="Social Credit" & dt$Party!="UFNZ" & dt$Party!="United New Zealand" & dt$Party!="ACT" & dt$Party!="Alliance" & dt$Party!="Progressive" & dt$Party!="Mana" & dt$Party!="GP" & dt$Party!="NL",]$Party = "I"
dt %>% group_by(Party) %>% tally()
dt$Party = relevel(dt$Party, "I")
# Drop unserious candidates
dtSerious = dt[dt$Party=="National" | dt$Party=="Labour" | dt$Party=="Maori" | dt$Party=="NZF" | dt$Party=="Social Credit" | dt$Party=="UFNZ" | dt$Party=="ACT" | dt$Party=="Alliance" | dt$Party=="Progressive" | dt$Party=="Mana" | dt$Party=="GP" | dt$Party=="NL" | dt$Party=="United NZ" | dt$Elected==1 | dt$VotePct>5, ]
# Drop uncontested electorate
dtSerious = dtSerious[dtSerious$Votes>-1,]
stopifnot(nrow(dtSerious)==7364) # Replication: Verify correct row count drop
dtSerious[dtSerious$Elected==1,] %>% group_by(Electorate) %>% summarise(numParties=length(unique(Party))) %>% arrange(numParties)
######################### END PREP
######################## PRE-ANALYSIS STUFF
# Histogram of tenure
pdf("histogramTenure.pdf")
hist(dtSerious[dtSerious$Incumbent==1,]$TermsServed, xlab="Terms Served", yaxt="n", ylab="", main="Histogram of Incumbent Tenure (NZ)")
dev.off()
# Initial model suffers from Multicollinearity
testModel = lm(Votes ~ PartyInGovt + TermsServed + Incumbent + as.factor(Party) + CabinetNow + CabinetEver + CabinetImportant + CabinetPM, data=dtSerious)
vif(testModel)
# Huge inflation from CabinetEver and CabinetNow--some inflation from Incumbent and TermsServed
# Prefer TermsServed going forward, drop CabinetEver; it's not a key part of the analysis to begin with.
baseIncumbencyRate = glm(Elected ~ Incumbent, family=binomial(link=logit), data=dtSerious)
govtIncumbencyRate = glm(Elected ~ Incumbent + PartyInGovt, family=binomial(link=logit), data=dtSerious)
# Base model: Elected ~ Incumbent -> 87% incumbent re-election rate; 89% for party in gov't.
############ MODEL 1: CROSS-SECTIONAL DATA
# Cross-sectional data:
crossSectionalModelPct = lm(VotePct ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + as.factor(Party), data=dtSerious)
summary(crossSectionalModelPct)
# Test for normal errors -- somewhat normal
qqPlot(crossSectionalModelPct)
# Test for influence using the old Cook's Distance rule of thumb.
cutoff <- 4/((nrow(dtSerious)-length(crossSectionalModelPct$coefficients)-2))
plot(crossSectionalModelPct, which=4, cook.levels=cutoff)
# Test for heteroskedasticity
ncvTest(crossSectionalModelPct)
# Try WLS to solve heteroskedasticity.
crossSectionalWLS = glm(VotePct ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + as.factor(Party), data=dtSerious, weights=1/resid(crossSectionalModelPct)^2)
# Alternative model specifications, but there's no there there.
summary(lm(VotePct ~ Incumbent + CabinetNow + as.factor(Party), data=dtSerious))
summary(lm(VotePct ~ Incumbent + CabinetNow + as.factor(Party) + PartyInGovt, data=dtSerious))
summary(lm(VotePct ~ Incumbent + CabinetNow + as.factor(Party), data=dtSerious))
library(survival)
library(dplyr)
library(car)
rm(list=ls())
#setwd("c:/Users/Tracey and Aaron/Dropbox/Field Paper/New Zealand Data/Merge/")
setwd("~/Dropbox/Field Paper/New Zealand Data/Merge/")
logitCoeffToPredictedProb = function(logitCoefs, values)
{
sum = sum(logitCoefs*values)
expValue = exp(sum)
return(expValue / (1+expValue))
}
############## PREP DATA #############
# Read the election data
dt = read.csv("output.csv", header=TRUE)
stopifnot(nrow(dt)==10267) # Replication, verify all rows loaded exactly
# Code party in government
dt$PartyInGovt = 0
dt[as.character(dt$Date)>="1940-04-01" & as.character(dt$Date)<="1949-12-12" & dt$Party=="Labour",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1949-12-13" & as.character(dt$Date)<="1957-12-11" & dt$Party=="National",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1957-12-12" & as.character(dt$Date)<="1960-12-11" & dt$Party=="Labour",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1960-12-12" & as.character(dt$Date)<="1972-12-07" & dt$Party=="National",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1972-12-08" & as.character(dt$Date)<="1975-12-12" & dt$Party=="Labour",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1975-12-13" & as.character(dt$Date)<="1984-07-26" & dt$Party=="National",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1984-07-26" & as.character(dt$Date)<="1990-11-01" & dt$Party=="Labour",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1990-11-02" & as.character(dt$Date)<="1996-11-12" & dt$Party=="National",]$PartyInGovt = 1
dt[as.character(dt$Date)>="1996-11-13" & as.character(dt$Date)<="1999-12-04" & (dt$Party=="National" | dt$Party=="NZF"),]$PartyInGovt = 1
dt[as.character(dt$Date)>="1999-12-05" & as.character(dt$Date)<="2008-11-18" & (dt$Party=="Labour" | dt$Party=="Alliance"),]$PartyInGovt = 1
dt[as.character(dt$Date)>="2008-11-19" & dt$Party=="National",]$PartyInGovt = 1
table(dt$PartyInGovt)
# Calculate vote percentage
dt = dt %>% group_by(Date, Electorate) %>% summarise(totalVotes=sum(Votes)) %>% merge(dt,.) %>% mutate(VotePct = round(100*Votes/totalVotes,2))
# Calculate lagged vote percentage (we'll lose some obs for incumbents who came in in 1946 because we don't have 1943 vote data!)
dt = dt %>% mutate(LastVotePct = lag(VotePct, order_by=ID))
# Pull list of parties who have elected people
dt %>% group_by(Party) %>% tally(Elected, sort=TRUE)
# Recode never elected parties into independents
dt %>% group_by(Party) %>% tally(sort=TRUE)
nrow(dt[dt$Party!="National" & dt$Party!="Labour" & dt$Party!="Maori" & dt$Party!="NZF" & dt$Party!="Social Credit" & dt$Party!="UFNZ" & dt$Party!="United New Zealand" & dt$Party!="ACT" & dt$Party!="Alliance" & dt$Party!="Progressive" & dt$Party!="Mana" & dt$Party!="GP" & dt$Party!="NL" & dt$Party!="United NZ",])
dt[dt$Party!="National" & dt$Party!="Labour" & dt$Party!="Maori" & dt$Party!="NZF" & dt$Party!="Social Credit" & dt$Party!="UFNZ" & dt$Party!="United New Zealand" & dt$Party!="ACT" & dt$Party!="Alliance" & dt$Party!="Progressive" & dt$Party!="Mana" & dt$Party!="GP" & dt$Party!="NL",]$Party = "I"
dt %>% group_by(Party) %>% tally()
dt$Party = relevel(dt$Party, "I")
# Drop unserious candidates
dtSerious = dt[dt$Party=="National" | dt$Party=="Labour" | dt$Party=="Maori" | dt$Party=="NZF" | dt$Party=="Social Credit" | dt$Party=="UFNZ" | dt$Party=="ACT" | dt$Party=="Alliance" | dt$Party=="Progressive" | dt$Party=="Mana" | dt$Party=="GP" | dt$Party=="NL" | dt$Party=="United NZ" | dt$Elected==1 | dt$VotePct>5, ]
# Drop uncontested electorate
dtSerious = dtSerious[dtSerious$Votes>-1,]
stopifnot(nrow(dtSerious)==7364) # Replication: Verify correct row count drop
dtSerious[dtSerious$Elected==1,] %>% group_by(Electorate) %>% summarise(numParties=length(unique(Party))) %>% arrange(numParties)
######################### END PREP
######################## PRE-ANALYSIS STUFF
# Histogram of tenure
pdf("histogramTenure.pdf")
hist(dtSerious[dtSerious$Incumbent==1,]$TermsServed, xlab="Terms Served", yaxt="n", ylab="", main="Histogram of Incumbent Tenure (NZ)")
dev.off()
# Initial model suffers from Multicollinearity
testModel = lm(Votes ~ PartyInGovt + TermsServed + Incumbent + as.factor(Party) + CabinetNow + CabinetEver + CabinetImportant + CabinetPM, data=dtSerious)
vif(testModel)
# Huge inflation from CabinetEver and CabinetNow--some inflation from Incumbent and TermsServed
# Prefer TermsServed going forward, drop CabinetEver; it's not a key part of the analysis to begin with.
baseIncumbencyRate = glm(Elected ~ Incumbent, family=binomial(link=logit), data=dtSerious)
govtIncumbencyRate = glm(Elected ~ Incumbent + PartyInGovt, family=binomial(link=logit), data=dtSerious)
# Base model: Elected ~ Incumbent -> 87% incumbent re-election rate; 89% for party in gov't.
############ MODEL 1: CROSS-SECTIONAL DATA
# Cross-sectional data:
crossSectionalModelPct = lm(VotePct ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + as.factor(Party), data=dtSerious)
summary(crossSectionalModelPct)
summary(lm(VotePct ~ Incumbent + CabinetNow + as.factor(Party) + PartyInGovt, data=dtSerious))
testModel = lm(Votes ~ PartyInGovt + TermsServed + Incumbent + as.factor(Party) + CabinetNow + CabinetEver + CabinetImportant + CabinetPM, data=dtSerious)
vif(testModel)
testModel = lm(Votes ~ PartyInGovt + TermsServed + Incumbent + as.factor(Party) + CabinetNow + CabinetImportant + CabinetPM, data=dtSerious)
vif(testModel)
summary(lm(VotePct ~ Incumbent + CabinetNow + as.factor(Party) + PartyInGovt, data=dtSerious))
summary(lm(VotePct ~ TermsServed + CabinetNow + as.factor(Party) + PartyInGovt, data=dtSerious))
summary(lm(VotePct ~ Incumbent + CabinetNow + as.factor(Party), data=dtSerious))
summary(lm(VotePct ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + as.factor(Party), data=dtSerious))
summary(lm(VotePct ~ TermsServed + CabinetNow + as.factor(Party), data=dtSerious))
summary(lm(VotePct ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + as.factor(Party) + PartyInGovt, data=dtSerious))
summary(lm(VotePct ~ Incumbent + CabinetNow + CabinetImportant + CabinetPM + as.factor(Party), data=dtSerious))
summary(lm(VotePct ~ Incumbent + CabinetNow, data=dtSerious[dtSerious$Party=="National",]))
summary(lm(VotePct ~ Incumbent + CabinetNow, data=dtSerious[dtSerious$Party=="Labour",]))
########### MODEL 2: CROSS-SECTIONAL LOGIT
logitModel = glm(Elected ~ as.factor(Party) + TermsServed + CabinetNow + CabinetImportant + CabinetPM + PartyInGovt, family=binomial(link=logit), data=dtSerious)
summary(logitModel)
summary(glm(Elected ~ Incumbent + CabinetNow + CabinetImportant + CabinetPM + PartyInGovt, family=binomial(link=logit), data=dtSerious))
prevCandidates = dtSerious[dtSerious$LastVotes>0 & dtSerious$Incumbent==1,]
timeSeriesModelVotes = lm(VotePct ~ PartyInGovt + TermsServed + as.factor(Party) + CabinetNow + CabinetImportant + CabinetPM + LastVotePct, data=prevCandidates)
summary(timeSeriesModelVotes)
summary(lm(VotePct ~ PartyInGovt + CabinetNow + LastVotePct, data=prevCandidates))
summary(timeSeriesModelVotes)
timeSeriesModelVotes = lm(VotePct ~ PartyInGovt + TermsServed + as.factor(Party) + CabinetNow + CabinetImportant + CabinetPM + LastVotePct, data=prevCandidates)
summary(timeSeriesModelVotes)
############ Appendix: Decade disaggregation
decadeDecomposition = matrix(NA,nrow=7,ncol=6)
for(i in 5:11)
{
minDate = 1900 + (10*i)
maxDate = minDate + 10
print(paste0("Decade: ",minDate,"-",maxDate))
candSubset = dtSerious[as.character(dtSerious$Date)>paste0(minDate,"-01-01") & as.character(dtSerious$Date)<paste0(maxDate,"-01-01"),]
print(nrow(candSubset))
crossSectionalModelVotesDecade = lm(VotePct ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + as.factor(Party) + PartyInGovt, data=candSubset)
timeSeriesModelVotesDecade = lm(VotePct ~ PartyInGovt + TermsServed + CabinetNow + CabinetImportant + CabinetPM + LastVotePct + as.factor(Party), data=candSubset[candSubset$LastVotes>0,])
logitModelDecade = glm(Elected ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + as.factor(Party), family=binomial(link=logit), data=candSubset)
decadeDecomposition[i-4,] =
round(c(
coef(summary(crossSectionalModelVotesDecade))[3,1],
coef(summary(crossSectionalModelVotesDecade))[3,4],
coef(summary(timeSeriesModelVotesDecade))[4,1],
coef(summary(timeSeriesModelVotesDecade))[4,4],
coef(summary(logitModelDecade))[3,1],
coef(summary(logitModelDecade))[3,4]
),2)
}
rownames(decadeDecomposition) = c("1950s", "1960s", "1970s", "1980s", "1990s", "2000s", "2010s")
colnames(decadeDecomposition) = c("CS Now Est.",
"p-Now",
"TS Now Est.",
"p-Now",
"Logit Now Est.",
"p-Now")
decadeDecomposition
electionDates = c("1949-11-30", "1951-09-01", "1954-11-13", "1957-11-30", "1960-11-26", "1963-11-30", "1966-11-26", "1969-11-29", "1972-11-25", "1975-11-29", "1978-11-25", "1981-11-28", "1984-07-14", "1987-08-15", "1990-10-27", "1993-11-06", "1996-10-12", "1999-11-27", "2002-07-27", "2005-09-17", "2008-11-08", "2011-11-26", "2014-09-20")
electionDecomposition = matrix(NA,nrow=length(electionDates),ncol=6)
i=1
for(election in electionDates)
{
candSubset = dtSerious[as.character(dtSerious$Date)==election,]
print(paste("Election ",election, "Candidates: ", nrow(candSubset)))
crossSectionalModelVotesDecade = lm(VotePct ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + as.factor(Party), data=candSubset)
timeSeriesModelVotesDecade = lm(VotePct ~ PartyInGovt + TermsServed + CabinetNow + CabinetImportant + CabinetPM + LastVotePct + as.factor(Party), data=candSubset[candSubset$LastVotes>0,])
logitModelDecade = glm(Elected ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + as.factor(Party), family=binomial(link=logit), data=candSubset)
electionDecomposition[i,] =
round(c(
coef(summary(crossSectionalModelVotesDecade))[3,1],
coef(summary(crossSectionalModelVotesDecade))[3,4],
coef(summary(timeSeriesModelVotesDecade))[4,1],
coef(summary(timeSeriesModelVotesDecade))[4,4],
coef(summary(logitModelDecade))[3,1],
coef(summary(logitModelDecade))[3,4]
),2)
i=i+1
}
rownames(electionDecomposition) = electionDates
colnames(electionDecomposition) = c("CS Now Est.",
"p-Now",
"TS Now Est.",
"p-Now",
"Logit Now Est.",
"p-Now")
electionDecomposition
#Synthetic observation export
library(dplyr)
rm(list=ls())
setwd("~/Dropbox/Field Paper/Canada Data/Merge/")
# Discard data before 1945 general election
dataT = dataT[as.character(dataT$Date)>="1945-06-11",]
stopifnot(nrow(dataT)==31638, min(as.character(dataT$Date))=="1945-06-11")
# Replication, verify all extraneous data was discarded correctly.
# Code party in government
dataT$PartyInGovt = 0
dataT[as.character(dataT$Date)>="1935-01-01" & as.character(dataT$Date)<="1948-11-14" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1948-11-15" & as.character(dataT$Date)<="1957-06-20" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1957-06-21" & as.character(dataT$Date)<="1963-04-21" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1963-04-22" & as.character(dataT$Date)<="1968-04-19" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1968-04-20" & as.character(dataT$Date)<="1979-06-02" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1979-06-02" & as.character(dataT$Date)<="1980-03-01" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1980-03-02" & as.character(dataT$Date)<="1984-09-15" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1984-09-17" & as.character(dataT$Date)<="1993-11-02" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1993-11-03" & as.character(dataT$Date)<="2006-02-05" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="2006-02-06" & dataT$Party=="C",]$PartyInGovt = 1
# Sanity check vote percentage calculations.
dataT = dataT %>% group_by(Date, Province, Riding) %>% summarise(totalVotes=sum(Votes)) %>% merge(dataT,.) %>% mutate(VotePctCalc = round(100*Votes/totalVotes,2))
dataT$Diff = dataT$VotePct - dataT$VotePctCalc
stopifnot(nrow(dataT[dataT$Diff>0,])==0)
# Drop unserious candidates
print(paste("Vote threshold check"))
for(i in seq(1,10))
{
print(paste0("Below ",i,"%: ",nrow(dataT[dataT$VotePct<i,]),". Major candidates below ",i,"%: ",nrow(dataT[dataT$VotePct<i & (dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="B.Q."),]),". Elected below ",i,"%: ",nrow(dataT[dataT$Elected & dataT$VotePct<i,])))
}
# Dropping ~10,000 candidates, losing 0 elected and only a few hundred from organized political parties.
# Compensate by including all major party candidates.
dtSerious = dataT[dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="CCF" | dataT$Party=="B.Q." | dataT$VotePct>5,]
dtSerious = dtSerious[dtSerious$Votes>-1,]
stopifnot(nrow(dtSerious)==22799) # Replication: Verify correct row count drop
# Recode party labels to only include major parties and other; no substantive reason to keep variation in that regard.
dtSerious[dtSerious$Party!="Lib" & dtSerious$Party!="P.C." & dtSerious$Party!="C" & dtSerious$Party!="CA" & dtSerious$Party!="N.D.P." & dtSerious$Party!="Ref." & dtSerious$Party!="CCF" & dtSerious$Party!="B.Q.",]$Party = "Ind."
dtSerious$Party = relevel(dtSerious$Party, "Ind.")
# Give me all those members whose last election status was 1 (i.e. they retired or died rather than lost in their last election)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
#Synthetic observation export
library(dplyr)
rm(list=ls())
setwd("~/Dropbox/Field Paper/Canada Data/Merge/")
dataT = read.csv("output.csv", header=TRUE)
# Discard data before 1945 general election
dataT = dataT[as.character(dataT$Date)>="1945-06-11",]
stopifnot(nrow(dataT)==31638, min(as.character(dataT$Date))=="1945-06-11")
# Replication, verify all extraneous data was discarded correctly.
# Code party in government
dataT$PartyInGovt = 0
dataT[as.character(dataT$Date)>="1935-01-01" & as.character(dataT$Date)<="1948-11-14" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1948-11-15" & as.character(dataT$Date)<="1957-06-20" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1957-06-21" & as.character(dataT$Date)<="1963-04-21" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1963-04-22" & as.character(dataT$Date)<="1968-04-19" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1968-04-20" & as.character(dataT$Date)<="1979-06-02" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1979-06-02" & as.character(dataT$Date)<="1980-03-01" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1980-03-02" & as.character(dataT$Date)<="1984-09-15" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1984-09-17" & as.character(dataT$Date)<="1993-11-02" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1993-11-03" & as.character(dataT$Date)<="2006-02-05" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="2006-02-06" & dataT$Party=="C",]$PartyInGovt = 1
# Sanity check vote percentage calculations.
dataT = dataT %>% group_by(Date, Province, Riding) %>% summarise(totalVotes=sum(Votes)) %>% merge(dataT,.) %>% mutate(VotePctCalc = round(100*Votes/totalVotes,2))
dataT$Diff = dataT$VotePct - dataT$VotePctCalc
stopifnot(nrow(dataT[dataT$Diff>0,])==0)
# Drop unserious candidates
print(paste("Vote threshold check"))
for(i in seq(1,10))
{
print(paste0("Below ",i,"%: ",nrow(dataT[dataT$VotePct<i,]),". Major candidates below ",i,"%: ",nrow(dataT[dataT$VotePct<i & (dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="B.Q."),]),". Elected below ",i,"%: ",nrow(dataT[dataT$Elected & dataT$VotePct<i,])))
}
# Dropping ~10,000 candidates, losing 0 elected and only a few hundred from organized political parties.
# Compensate by including all major party candidates.
dtSerious = dataT[dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="CCF" | dataT$Party=="B.Q." | dataT$VotePct>5,]
dtSerious = dtSerious[dtSerious$Votes>-1,]
stopifnot(nrow(dtSerious)==22799) # Replication: Verify correct row count drop
# Recode party labels to only include major parties and other; no substantive reason to keep variation in that regard.
dtSerious[dtSerious$Party!="Lib" & dtSerious$Party!="P.C." & dtSerious$Party!="C" & dtSerious$Party!="CA" & dtSerious$Party!="N.D.P." & dtSerious$Party!="Ref." & dtSerious$Party!="CCF" & dtSerious$Party!="B.Q.",]$Party = "Ind."
dtSerious$Party = relevel(dtSerious$Party, "Ind.")
# Give me all those members whose last election status was 1 (i.e. they retired or died rather than lost in their last election)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
View(ghostCandidates)
matchElectionDate = function(electionDates, singleDate)
{
for(i in 1:length(electionDates))
{
if(as.character(electionDates[i])==as.character(singleDate)) { break }
}
return(electionDates[i+1])
}
electionDates = c("1945-06-11","1949-06-27","1953-08-10","1957-06-10","1958-03-31","1962-06-18","1963-04-08","1965-11-08","1968-06-25","1972-10-30","1974-07-08","1979-05-22","1980-02-18","1984-09-04","1988-11-21","1993-10-25","1997-06-02","2000-11-27","2004-06-28","2006-01-23","2008-10-14","2011-05-02","2015-10-19")
matchElectionDate(electionDates, "1945-06-11")
matchElectionDate(electionDates, "1953-08-10")
matchElectionDate = function(electionDates, singleDate)
{
for(i in 1:length(electionDates))
{
if(as.character(electionDates[i])>as.character(singleDate)) { break }
}
return(electionDates[i])
}
electionDates = c("1945-06-11","1949-06-27","1953-08-10","1957-06-10","1958-03-31","1962-06-18","1963-04-08","1965-11-08","1968-06-25","1972-10-30","1974-07-08","1979-05-22","1980-02-18","1984-09-04","1988-11-21","1993-10-25","1997-06-02","2000-11-27","2004-06-28","2006-01-23","2008-10-14","2011-05-02","2015-10-19")
matchElectionDate(electionDates, "1953-08-11")
electionDates = c("1945-06-11","1949-06-27","1953-08-10","1957-06-10","1958-03-31","1962-06-18","1963-04-08","1965-11-08","1968-06-25","1972-10-30","1974-07-08","1979-05-22","1980-02-18","1984-09-04","1988-11-21","1993-10-25","1997-06-02","2000-11-27","2004-06-28","2006-01-23","2008-10-14","2011-05-02","2015-10-19")
# Give me all those members whose last election status was 1 (i.e. they retired or died rather than lost in their last election)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), nextDate = matchElectionDate(electionDates, Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, nextDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
warnings()
# Helper func for dplyr to figure out when we are looking for cabinet covariate data.
matchElectionDate = function(singleDate)
{
electionDates = c("1945-06-11","1949-06-27","1953-08-10","1957-06-10","1958-03-31","1962-06-18","1963-04-08","1965-11-08","1968-06-25","1972-10-30","1974-07-08","1979-05-22","1980-02-18","1984-09-04","1988-11-21","1993-10-25","1997-06-02","2000-11-27","2004-06-28","2006-01-23","2008-10-14","2011-05-02","2015-10-19")
for(i in 1:length(electionDates))
{
if(as.character(electionDates[i])>as.character(singleDate)) { break }
}
return(electionDates[i])
}
# Give me all those members whose last election status was 1 (i.e. they retired or died rather than lost in their last election)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), nextDate = matchElectionDate(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, nextDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
warnings()
matchElectionDate = function(singleDate)
{
print(singleDate)
electionDates = c("1945-06-11","1949-06-27","1953-08-10","1957-06-10","1958-03-31","1962-06-18","1963-04-08","1965-11-08","1968-06-25","1972-10-30","1974-07-08","1979-05-22","1980-02-18","1984-09-04","1988-11-21","1993-10-25","1997-06-02","2000-11-27","2004-06-28","2006-01-23","2008-10-14","2011-05-02","2015-10-19")
for(i in 1:length(electionDates))
{
if(as.character(electionDates[i])>as.character(singleDate)) { break }
}
return(electionDates[i])
}
# Give me all those members whose last election status was 1 (i.e. they retired or died rather than lost in their last election)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), nextDate = matchElectionDate(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, nextDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
matchElectionDate = function(singleDate)
{
print(singleDate)
electionDates = c("1945-06-11","1949-06-27","1953-08-10","1957-06-10","1958-03-31","1962-06-18","1963-04-08","1965-11-08","1968-06-25","1972-10-30","1974-07-08","1979-05-22","1980-02-18","1984-09-04","1988-11-21","1993-10-25","1997-06-02","2000-11-27","2004-06-28","2006-01-23","2008-10-14","2011-05-02","2015-10-19","2019-01-01")
for(i in 1:length(electionDates))
{
if(as.character(electionDates[i])>as.character(singleDate)) { break }
}
return(electionDates[i])
}
matchElectionDate = function(singleDate)
{
electionDates = c("1945-06-11","1949-06-27","1953-08-10","1957-06-10","1958-03-31","1962-06-18","1963-04-08","1965-11-08","1968-06-25","1972-10-30","1974-07-08","1979-05-22","1980-02-18","1984-09-04","1988-11-21","1993-10-25","1997-06-02","2000-11-27","2004-06-28","2006-01-23","2008-10-14","2011-05-02","2015-10-19","2019-01-01")
for(i in 1:length(electionDates))
{
if(as.character(electionDates[i])>as.character(singleDate)) { break }
}
return(electionDates[i])
}
# Give me all those members whose last election status was 1 (i.e. they retired or died rather than lost in their last election)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), nextDate = matchElectionDate(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, nextDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, nextDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
#Synthetic observation export
library(dplyr)
rm(list=ls())
setwd("~/Dropbox/Field Paper/Canada Data/Merge/")
dataT = read.csv("output.csv", header=TRUE)
# Discard data before 1945 general election
dataT = dataT[as.character(dataT$Date)>="1945-06-11",]
stopifnot(nrow(dataT)==31638, min(as.character(dataT$Date))=="1945-06-11")
# Replication, verify all extraneous data was discarded correctly.
# Code party in government
dataT$PartyInGovt = 0
dataT[as.character(dataT$Date)>="1935-01-01" & as.character(dataT$Date)<="1948-11-14" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1948-11-15" & as.character(dataT$Date)<="1957-06-20" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1957-06-21" & as.character(dataT$Date)<="1963-04-21" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1963-04-22" & as.character(dataT$Date)<="1968-04-19" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1968-04-20" & as.character(dataT$Date)<="1979-06-02" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1979-06-02" & as.character(dataT$Date)<="1980-03-01" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1980-03-02" & as.character(dataT$Date)<="1984-09-15" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1984-09-17" & as.character(dataT$Date)<="1993-11-02" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1993-11-03" & as.character(dataT$Date)<="2006-02-05" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="2006-02-06" & dataT$Party=="C",]$PartyInGovt = 1
# Sanity check vote percentage calculations.
dataT = dataT %>% group_by(Date, Province, Riding) %>% summarise(totalVotes=sum(Votes)) %>% merge(dataT,.) %>% mutate(VotePctCalc = round(100*Votes/totalVotes,2))
dataT$Diff = dataT$VotePct - dataT$VotePctCalc
stopifnot(nrow(dataT[dataT$Diff>0,])==0)
# Drop unserious candidates
print(paste("Vote threshold check"))
for(i in seq(1,10))
{
print(paste0("Below ",i,"%: ",nrow(dataT[dataT$VotePct<i,]),". Major candidates below ",i,"%: ",nrow(dataT[dataT$VotePct<i & (dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="B.Q."),]),". Elected below ",i,"%: ",nrow(dataT[dataT$Elected & dataT$VotePct<i,])))
}
# Dropping ~10,000 candidates, losing 0 elected and only a few hundred from organized political parties.
# Compensate by including all major party candidates.
dtSerious = dataT[dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="CCF" | dataT$Party=="B.Q." | dataT$VotePct>5,]
dtSerious = dtSerious[dtSerious$Votes>-1,]
stopifnot(nrow(dtSerious)==22799) # Replication: Verify correct row count drop
# Recode party labels to only include major parties and other; no substantive reason to keep variation in that regard.
dtSerious[dtSerious$Party!="Lib" & dtSerious$Party!="P.C." & dtSerious$Party!="C" & dtSerious$Party!="CA" & dtSerious$Party!="N.D.P." & dtSerious$Party!="Ref." & dtSerious$Party!="CCF" & dtSerious$Party!="B.Q.",]$Party = "Ind."
dtSerious$Party = relevel(dtSerious$Party, "Ind.")
# Give me all those members whose last election status was 1 (i.e. they retired or died rather than lost in their last election)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
View(ghostCandidates)
?write.csv
#Synthetic observation export
library(dplyr)
rm(list=ls())
setwd("~/Dropbox/Field Paper/Canada Data/Merge/")
dataT = read.csv("output.csv", header=TRUE)
# Discard data before 1945 general election
dataT = dataT[as.character(dataT$Date)>="1945-06-11",]
stopifnot(nrow(dataT)==31638, min(as.character(dataT$Date))=="1945-06-11")
# Replication, verify all extraneous data was discarded correctly.
# Code party in government
dataT$PartyInGovt = 0
dataT[as.character(dataT$Date)>="1935-01-01" & as.character(dataT$Date)<="1948-11-14" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1948-11-15" & as.character(dataT$Date)<="1957-06-20" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1957-06-21" & as.character(dataT$Date)<="1963-04-21" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1963-04-22" & as.character(dataT$Date)<="1968-04-19" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1968-04-20" & as.character(dataT$Date)<="1979-06-02" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1979-06-02" & as.character(dataT$Date)<="1980-03-01" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1980-03-02" & as.character(dataT$Date)<="1984-09-15" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1984-09-17" & as.character(dataT$Date)<="1993-11-02" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1993-11-03" & as.character(dataT$Date)<="2006-02-05" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="2006-02-06" & dataT$Party=="C",]$PartyInGovt = 1
# Sanity check vote percentage calculations.
dataT = dataT %>% group_by(Date, Province, Riding) %>% summarise(totalVotes=sum(Votes)) %>% merge(dataT,.) %>% mutate(VotePctCalc = round(100*Votes/totalVotes,2))
dataT$Diff = dataT$VotePct - dataT$VotePctCalc
stopifnot(nrow(dataT[dataT$Diff>0,])==0)
# Drop unserious candidates
print(paste("Vote threshold check"))
for(i in seq(1,10))
{
print(paste0("Below ",i,"%: ",nrow(dataT[dataT$VotePct<i,]),". Major candidates below ",i,"%: ",nrow(dataT[dataT$VotePct<i & (dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="B.Q."),]),". Elected below ",i,"%: ",nrow(dataT[dataT$Elected & dataT$VotePct<i,])))
}
# Dropping ~10,000 candidates, losing 0 elected and only a few hundred from organized political parties.
# Compensate by including all major party candidates.
dtSerious = dataT[dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="CCF" | dataT$Party=="B.Q." | dataT$VotePct>5,]
dtSerious = dtSerious[dtSerious$Votes>-1,]
stopifnot(nrow(dtSerious)==22799) # Replication: Verify correct row count drop
# Recode party labels to only include major parties and other; no substantive reason to keep variation in that regard.
dtSerious[dtSerious$Party!="Lib" & dtSerious$Party!="P.C." & dtSerious$Party!="C" & dtSerious$Party!="CA" & dtSerious$Party!="N.D.P." & dtSerious$Party!="Ref." & dtSerious$Party!="CCF" & dtSerious$Party!="B.Q.",]$Party = "Ind."
dtSerious$Party = relevel(dtSerious$Party, "Ind.")
# Give me all those members whose last election status was 1 (i.e. they retired or died rather than lost in their last election)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
setwd("~/Dropbox/Field Paper/Canada Data/SyntheticObs/")
write.csv(ghostCandidates,"synthIn.csv")
#Synthetic observation export
library(dplyr)
rm(list=ls())
setwd("~/Dropbox/Field Paper/Canada Data/Merge/")
dataT = read.csv("output.csv", header=TRUE)
# Discard data before 1945 general election
dataT = dataT[as.character(dataT$Date)>="1945-06-11",]
stopifnot(nrow(dataT)==31638, min(as.character(dataT$Date))=="1945-06-11")
# Replication, verify all extraneous data was discarded correctly.
# Code party in government
dataT$PartyInGovt = 0
dataT[as.character(dataT$Date)>="1935-01-01" & as.character(dataT$Date)<="1948-11-14" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1948-11-15" & as.character(dataT$Date)<="1957-06-20" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1957-06-21" & as.character(dataT$Date)<="1963-04-21" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1963-04-22" & as.character(dataT$Date)<="1968-04-19" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1968-04-20" & as.character(dataT$Date)<="1979-06-02" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1979-06-02" & as.character(dataT$Date)<="1980-03-01" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1980-03-02" & as.character(dataT$Date)<="1984-09-15" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1984-09-17" & as.character(dataT$Date)<="1993-11-02" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1993-11-03" & as.character(dataT$Date)<="2006-02-05" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="2006-02-06" & dataT$Party=="C",]$PartyInGovt = 1
# Sanity check vote percentage calculations.
dataT = dataT %>% group_by(Date, Province, Riding) %>% summarise(totalVotes=sum(Votes)) %>% merge(dataT,.) %>% mutate(VotePctCalc = round(100*Votes/totalVotes,2))
dataT$Diff = dataT$VotePct - dataT$VotePctCalc
stopifnot(nrow(dataT[dataT$Diff>0,])==0)
# Drop unserious candidates
print(paste("Vote threshold check"))
for(i in seq(1,10))
{
print(paste0("Below ",i,"%: ",nrow(dataT[dataT$VotePct<i,]),". Major candidates below ",i,"%: ",nrow(dataT[dataT$VotePct<i & (dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="B.Q."),]),". Elected below ",i,"%: ",nrow(dataT[dataT$Elected & dataT$VotePct<i,])))
}
# Dropping ~10,000 candidates, losing 0 elected and only a few hundred from organized political parties.
# Compensate by including all major party candidates.
dtSerious = dataT[dataT$Party=="Lib" | dataT$Party=="P.C." | dataT$Party=="C" | dataT$Party=="CA" | dataT$Party=="N.D.P." | dataT$Party=="Ref." | dataT$Party=="CCF" | dataT$Party=="B.Q." | dataT$VotePct>5,]
dtSerious = dtSerious[dtSerious$Votes>-1,]
stopifnot(nrow(dtSerious)==22799) # Replication: Verify correct row count drop
# Recode party labels to only include major parties and other; no substantive reason to keep variation in that regard.
dtSerious[dtSerious$Party!="Lib" & dtSerious$Party!="P.C." & dtSerious$Party!="C" & dtSerious$Party!="CA" & dtSerious$Party!="N.D.P." & dtSerious$Party!="Ref." & dtSerious$Party!="CCF" & dtSerious$Party!="B.Q.",]$Party = "Ind."
dtSerious$Party = relevel(dtSerious$Party, "Ind.")
# Give me all those members whose last election status was 1 (i.e. they retired or died rather than lost in their last election)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDataSet, exitDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
setwd("~/Dropbox/Field Paper/Canada Data/SyntheticObs/")
write.csv(ghostCandidates,"synthIn.csv", row.names=FALSE)
ghostCandidates = dtSerious[dtSerious$Incumbent==1 | dtSerious$Elected==1,] %>% group_by(ID) %>% summarise(name=last(Name), exitDataSet=last(Elected), exitDate=last(Date), termsServed=last(TermsServed), Party=last(Party)) %>% mutate(needGhostRow = as.integer(as.character(exitDate)!="2015-10-19") * as.integer(exitDataSet)) %>% select(ID, name, exitDate, needGhostRow, termsServed, Party) %>% filter(needGhostRow==1)
setwd("~/Dropbox/Field Paper/Canada Data/SyntheticObs/")
write.csv(ghostCandidates,"synthIn.csv", row.names=FALSE)
