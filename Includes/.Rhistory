############
########### MODEL 3: CROSS-SECTIONAL LOGIT #####
logitModelNZ = glm(Elected ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed + as.factor(Party), family=binomial(link=logit), data=NZdtSerious)
summary(logitModelNZ)
logitCoeffToPredictedProb(c(-6.12,4.76,3.37),c(1,1,0))
logitCoeffToPredictedProb(c(-6.12,4.76,3.37),c(1,1,1))
logitMartinNZ = glm(Elected ~ CabinetNow + Incumbent + as.factor(Party), family=binomial(link=logit), data=NZdtSerious)
summary(logitMartinNZ)
preMMP = glm(Elected ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed + as.factor(Party), family=binomial(link=logit), data=NZdtSerious[as.character(NZdtSerious$Date)<="1994-01-01",])
postMMP = glm(Elected ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed + as.factor(Party), family=binomial(link=logit), data=NZdtSerious[as.character(NZdtSerious$Date)>="1994-01-01",])
logitCoeffToPredictedProb(c(coef(preMMP)[1], coef(preMMP)[2], coef(preMMP)[5], coef(preMMP)[6], coef(preMMP)[10]), c(1,0,1,1,1))
logitCoeffToPredictedProb(c(coef(preMMP)[1], coef(preMMP)[2], coef(preMMP)[5], coef(preMMP)[6], coef(preMMP)[10]), c(1,1,1,1,1))
# 39% -> 33%
logitCoeffToPredictedProb(c(coef(postMMP)[1], coef(postMMP)[2], coef(postMMP)[5], coef(postMMP)[6], coef(postMMP)[10]), c(1,0,1,1,1))
logitCoeffToPredictedProb(c(coef(postMMP)[1], coef(postMMP)[2], coef(postMMP)[5], coef(postMMP)[6], coef(postMMP)[10]), c(1,1,1,1,1))
# 27% -> 49%
# For a better estimate of uncertainty, bootstrap the CI of the first-difference and each coefficient
set.seed(19861108) # For replication, fix seed for bootstraping.
iterations = 1000
predProb0NZ = numeric(iterations)
predProb1NZ = numeric(iterations)
coefMatrixNZ = matrix(data=NA, nrow=iterations, ncol=18)
coefMatrixMNZ = matrix(data=NA, nrow=iterations, ncol=15)
for(i in 1:iterations)
{
if(i%%100==0)
{
print(paste(i,"samples for bootstrap"))
}
bootstrapData = NZdtSerious[sample(nrow(NZdtSerious), nrow(NZdtSerious), replace=TRUE),]
logitModelSample = glm(Elected ~ CabinetNow + TermsServed + CabinetImportant + CabinetPM + PartyInGovt + as.factor(Party), family=binomial(link=logit), data=bootstrapData)
martinModelSample = glm(Elected ~ CabinetNow + Incumbent + as.factor(Party), family=binomial(link=logit), data=bootstrapData)
coefMatrixNZ[i,] = coef(logitModelSample)
coefMatrixMNZ[i,] = coef(martinModelSample)
predProb0NZ[i] = logitCoeffToPredictedProb(
c(
coef(logitModelSample)[1],
coef(logitModelSample)[2],
coef(logitModelSample)[3],
coef(logitModelSample)[6],
coef(logitModelSample)[10]
),
c(1, 0, 2, 1, 1)
)
predProb1NZ[i] = logitCoeffToPredictedProb(
c(
coef(logitModelSample)[1],
coef(logitModelSample)[2],
coef(logitModelSample)[3],
coef(logitModelSample)[6],
coef(logitModelSample)[10]
),
c(1, 1, 2, 1, 1)
)
}
logitEstimatesNZ = numeric(ncol(coefMatrixNZ))
logitEstimatesMNZ = numeric(ncol(coefMatrixMNZ))
CIsNZ = matrix(NA, ncol=2, nrow=ncol(coefMatrixNZ))
CIsMNZ = matrix(NA, ncol=2, nrow=ncol(coefMatrixMNZ))
for(i in 1:ncol(coefMatrixNZ))
{
coefInterest = coefMatrixNZ[,i]
logitEstimatesNZ[i] = mean(coefInterest)
CIsNZ[i,] = quantile(coefInterest, c(0.025, 0.975))
}
for(i in 1:ncol(coefMatrixMNZ))
{
coefInterestM = coefMatrixMNZ[,i]
logitEstimatesMNZ[i] = mean(coefInterestM)
CIsMNZ[i,] = quantile(coefInterestM, c(0.025, 0.975))
}
names(logitEstimatesNZ) = names(logitModelSample$coefficients)
names(logitEstimatesMNZ) = names(martinModelSample$coefficients)
rownames(CIsNZ) = names(logitModelSample$coefficients)
rownames(CIsMNZ) = names(martinModelSample$coefficients)
print(CIsNZ)
summary(glm(Elected ~ as.factor(Party) + Incumbent + CabinetNow + CabinetImportant + CabinetPM + PartyInGovt, family=binomial(link=logit), data=NZdtSerious))
###########
############ MODEL 4: SURVIVAL DATA #####
survivalSubset = NZdtSerious[NZdtSerious$Incumbent==1,c("ID","Name","Incumbent","TermsServed","CabinetNow","CabinetImportant","CabinetPM","Date","Elected","Party", "PartyInGovt")]
survivalDataNZ = survivalSubset %>% mutate(start=TermsServed-1, end=TermsServed, death=as.integer(!Elected==1), pName=as.character(Party)) %>% select(ID, start, end, death, CabinetNow, CabinetImportant, CabinetPM, PartyInGovt, pName)
survivalDataNZ$pName = as.factor(survivalDataNZ$pName)
survivalDataNZ$pName = relevel(survivalDataNZ$pName, "I")
survivalDVNZ = Surv(survivalDataNZ$start, survivalDataNZ$end, survivalDataNZ$death)
survivalModelNZ = coxph(survivalDVNZ ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + pName, data=survivalDataNZ)
summary(survivalModelNZ)
survModelPlotDataNZ = data.frame(CabinetNow=c(0, 1), CabinetImportant=c(0,0), CabinetPM=c(0,0), PartyInGovt=c(1,1), pName=c("Labour","Labour"))
ciMatrixSurvivalNZ = list(cbind(summary(survivalModelNZ)$conf.int[,3],
summary(survivalModelNZ)$conf.int[,4]))
# Diagnostics: Is the hazard proportional?
# Null hypothesis: Proportional hazard is appropriate; reject null: proportional hazard is not appropriate.
cox.zph(survivalModelNZ)
syntheticObs = read.csv("New Zealand Data/SyntheticObs/synthOut.csv")
syntheticSurvive = syntheticObs %>% mutate(start=TermsServed-1, end=TermsServed, death=1, pName=as.character(Party)) %>% select(ID, start, end, death, CabinetNow, CabinetImportant, CabinetPM, PartyInGovt, pName)
combinedSurvivalDataNZ = rbind(survivalDataNZ, syntheticSurvive)
combinedSurvivalDVNZ = Surv(combinedSurvivalDataNZ$start, combinedSurvivalDataNZ$end, combinedSurvivalDataNZ$death)
combinedModelNZ = coxph(combinedSurvivalDVNZ ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + pName, data=combinedSurvivalDataNZ)
ciMatrixCombNZ = list(cbind(summary(combinedModelNZ)$conf.int[,3], summary(combinedModelNZ)$conf.int[,4]))
# Save data for plot generator
save(NZdtSerious, survivalModelNZ, combinedModelNZ, survModelPlotDataNZ,
crossSecModelNZ, crossSecMartinNZ, controlShareModelNZ,
firstDiffModelNZ, martinFDModelNZ, predProb0NZ, predProb1NZ,
logitModelNZ, logitMartinNZ, logitEstimatesNZ, logitEstimatesMNZ,
CIsNZ, CIsMNZ, ciMatrixSurvivalNZ, ciMatrixCombNZ,
survivalDataNZ, combinedSurvivalDataNZ, survivalDVNZ, combinedSurvivalDVNZ,
preMMP, postMMP,
file="New Zealand Data/Merge/OutputNZ.RData")
##### Party List Data ####
listData = NZdtSerious[NZdtSerious$Date=="1996-10-12" | NZdtSerious$Date=="1999-11-27" | NZdtSerious$Date=="2002-07-27" | NZdtSerious$Date=="2005-09-17" | NZdtSerious$Date=="2008-11-08" | NZdtSerious$Date=="2011-11-26" | NZdtSerious$Date=="2014-09-20" ,]
# Only grab general elections. By-elections for electorate members are electorate by-elections
# List resignations go further down the list, so no by-election is relevant
# Lagged cabinet variable (now can do a diff in diff)
listData = listData %>% arrange(ID,Date) %>% mutate(LastCabinet=lag(CabinetNow))
govtListData = listData[listData$PartyInGovt==1 & (listData$Party=="National" | listData$Party=="Labour"),]
govtListData %>% group_by(Party, Date) %>% summarise(minList=min(ListPosition), maxList=max(ListPosition), numCand=n())
# Recode unlisted MPs to be tied at the bottom of the list
govtListData[govtListData$Party=="Labour" & govtListData$Date=="1999-11-27" & govtListData$LastListPosition==0,]$LastListPosition=61
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2002-07-27" & govtListData$LastListPosition==0,]$LastListPosition=66
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2005-09-17" & govtListData$LastListPosition==0,]$LastListPosition=75
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2008-11-08" & govtListData$LastListPosition==0,]$LastListPosition=76
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2011-11-26" & govtListData$LastListPosition==0,]$LastListPosition=78
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2014-09-20" & govtListData$LastListPosition==0,]$LastListPosition=71
govtListData[govtListData$Party=="Labour" & govtListData$Date=="1996-10-12" & govtListData$ListPosition==0,]$ListPosition=61
govtListData[govtListData$Party=="Labour" & govtListData$Date=="1999-11-27" & govtListData$ListPosition==0,]$ListPosition=66
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2002-07-27" & govtListData$ListPosition==0,]$ListPosition=75
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2005-09-17" & govtListData$ListPosition==0,]$ListPosition=76
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2008-11-08" & govtListData$ListPosition==0,]$ListPosition=78
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2011-11-26" & govtListData$ListPosition==0,]$ListPosition=71
govtListData[govtListData$Party=="Labour" & govtListData$Date=="2014-09-20" & govtListData$ListPosition==0,]$ListPosition=65
govtListData[govtListData$Party=="National" & govtListData$Date=="1999-11-27" & govtListData$LastListPosition==0,]$LastListPosition=66
govtListData[govtListData$Party=="National" & govtListData$Date=="2002-07-27" & govtListData$LastListPosition==0,]$LastListPosition=65
govtListData[govtListData$Party=="National" & govtListData$Date=="2005-09-17" & govtListData$LastListPosition==0,]$LastListPosition=66
govtListData[govtListData$Party=="National" & govtListData$Date=="2008-11-08" & govtListData$LastListPosition==0,]$LastListPosition=66
govtListData[govtListData$Party=="National" & govtListData$Date=="2011-11-26" & govtListData$LastListPosition==0,]$LastListPosition=73
govtListData[govtListData$Party=="National" & govtListData$Date=="2014-09-20" & govtListData$LastListPosition==0,]$LastListPosition=76
govtListData[govtListData$Party=="National" & govtListData$Date=="1996-10-12" & govtListData$ListPosition==0,]$ListPosition=66
govtListData[govtListData$Party=="National" & govtListData$Date=="1999-11-27" & govtListData$ListPosition==0,]$ListPosition=64
govtListData[govtListData$Party=="National" & govtListData$Date=="2002-07-27" & govtListData$ListPosition==0,]$ListPosition=65
govtListData[govtListData$Party=="National" & govtListData$Date=="2005-09-17" & govtListData$ListPosition==0,]$ListPosition=65
govtListData[govtListData$Party=="National" & govtListData$Date=="2008-11-08" & govtListData$ListPosition==0,]$ListPosition=72
govtListData[govtListData$Party=="National" & govtListData$Date=="2011-11-26" & govtListData$ListPosition==0,]$ListPosition=75
govtListData[govtListData$Party=="National" & govtListData$Date=="2014-09-20" & govtListData$ListPosition==0,]$ListPosition=75
# Create delta variable
govtListData = govtListData %>% mutate(FD=ListPosition-LastListPosition)
# delta for each possible group.
enter = govtListData[as.character(govtListData$Date)>="1997-01-01" & govtListData$LastCabinet==0 & govtListData$CabinetNow==1,]$FD
stay = govtListData[as.character(govtListData$Date)>="1997-01-01" & govtListData$LastCabinet==1 & govtListData$CabinetNow==1,]$FD
exit = govtListData[as.character(govtListData$Date)>="1997-01-01" & govtListData$LastCabinet==1 & govtListData$CabinetNow==0,]$FD
stayout = govtListData[as.character(govtListData$Date)>="1997-01-01" & govtListData$LastCabinet==0 & govtListData$CabinetNow==0,]$FD
# T test is not quite the appropriate statistic, but the DiM is obviously not an effect
t_test(enter,stayout)
# Can't reject null hypothesis re: cabinet list placing.
# See, no real difference
mean(enter)
mean(stay)
mean(exit)
mean(stayout)
# Inference about trajectory over time
mean(govtListData[govtListData$Incumbent==0,]$ListPosition)
mean(govtListData[govtListData$Incumbent==0 & govtListData$Elected==1,]$ListPosition)
mean(govtListData[govtListData$Incumbent==1 & govtListData$TermsServed==1,]$FD)
mean(govtListData[govtListData$Incumbent==1 & govtListData$TermsServed==2,]$FD)
mean(govtListData[govtListData$Incumbent==1 & govtListData$TermsServed==3,]$FD)
#### End party list discussion
############ Appendix: Decade disaggregation ####
decadeDecomposition = matrix(NA,nrow=7,ncol=12)
for(i in 5:11)
{
minDate = 1900 + (10*i)
maxDate = minDate + 10
print(paste0("Decade: ",minDate,"-",maxDate))
candSubset = NZdtSerious[as.character(NZdtSerious$Date)>paste0(minDate,"-01-01") & as.character(NZdtSerious$Date)<paste0(maxDate,"-01-01"),]
print(nrow(candSubset))
crossSectionalModelVotesDecade = lm(VotePct ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + as.factor(Party) + PartyInGovt, data=candSubset)
timeSeriesModelVotesDecade = lm(VotePct ~ TermsServed + PartyInGovt + CabinetNow + CabinetImportant + CabinetPM + LastVotePct + as.factor(Party), data=candSubset[candSubset$Incumbent==1 & candSubset$LastVotes>0,])
logitModelDecade = glm(Elected ~ TermsServed + CabinetNow + CabinetImportant + CabinetPM + as.factor(Party) + PartyInGovt, family=binomial(link=logit), data=candSubset)
decadeDecomposition[i-4,] =
round(c(
coeftest(crossSectionalModelVotesDecade,sandwich)[3,1],
coeftest(crossSectionalModelVotesDecade,sandwich)[3,1] - 1.96*coeftest(crossSectionalModelVotesDecade,sandwich)[3,2],
coeftest(crossSectionalModelVotesDecade,sandwich)[3,1] + 1.96*coeftest(crossSectionalModelVotesDecade,sandwich)[3,2],
coeftest(crossSectionalModelVotesDecade,sandwich)[3,4],
coeftest(timeSeriesModelVotesDecade,sandwich)[4,1],
coeftest(timeSeriesModelVotesDecade,sandwich)[4,1] - 1.96*coeftest(timeSeriesModelVotesDecade,sandwich)[4,2],
coeftest(timeSeriesModelVotesDecade,sandwich)[4,1] + 1.96*coeftest(timeSeriesModelVotesDecade,sandwich)[4,2],
coeftest(timeSeriesModelVotesDecade,sandwich)[4,4],
coef(summary(logitModelDecade))[3,1],
coef(summary(logitModelDecade))[3,1] - 1.96*coef(summary(logitModelDecade))[3,2],
coef(summary(logitModelDecade))[3,1] + 1.96*coef(summary(logitModelDecade))[3,2],
coef(summary(logitModelDecade))[3,4]
),2)
}
rownames(decadeDecomposition) = c("1950s", "1960s", "1970s", "1980s", "1990s", "2000s", "2010s")
colnames(decadeDecomposition) = c("Model 1",
"Model 1 CIL",
"Model 1 CIH",
"Model 1 P",
"Model 2",
"Model 2 CIL",
"Model 2 CIH",
"Model 2 P",
"Model 3",
"Model 3 CIL",
"Model 3 CIH",
"Model 3 P")
decadeDecomposition
write.table(decadeDecomposition, "Includes/decadeDecompositionNZ.txt",quote=FALSE, sep="\t")
rm(list=ls())
library(survival) # Survival modeling
library(stargazer) # Output tables
library(sandwich) # Robust SEs
library(lmtest) # Robust SEs
####### MODIFY DATA PATHS ON LINES 19 AND 21 BEFORE RUNNING CODE.
####### NOTES ON HOW PRINTED FIGURES DIFFER FROM REPLICATION CODE
# 1) Coefficients of interest are bolded for visual effect
# 2) New Zealand discussion graph is generated in New Zealand
##################################################################
setwd("~/Dropbox/Field Paper/Canada Data/Merge/")
#### Generate figures and plots from stashed RData
setwd("../Canada Data/Merge/")
load("OutputCA.RData")
setwd("../../New Zealand Data/Merge/")
load("OutputNZ.RData")
setwd("../../Includes/")
#####
# Histogram of party tenure, Canada
pdf("histogramTenureCA.pdf")
hist(CAdtSerious[CAdtSerious$Incumbent==1,]$TermsServed, xlab="Terms Served", yaxt="n", ylab="", main="Histogram of Incumbent Tenure (Canada)")
dev.off()
pdf("histogramTenureNZ.pdf")
hist(NZdtSerious[NZdtSerious$Incumbent==1,]$TermsServed, xlab="Terms Served", yaxt="n", ylab="", main="Histogram of Incumbent Tenure (NZ)")
dev.off()
# Survival Model sans synth obs, Canada
pdf("survivalModelCA.pdf")
plot(survfit(survivalModelCA, newdata=survModelPlotDataCA), conf.int=TRUE, main="Canada: Survival Model (No Synthetic Obs)", xlab="Terms in Government", ylab="Survival Rate", col=c("black","red"))
legend(x=8,y=0.95,c("Backbencher","Cabinet"),col=c("black","red"),lty=1)
dev.off()
# Survival Model with synth obs, Canada
pdf("combinedModelCA.pdf")
plot(survfit(combinedModelCA, newdata=survModelPlotDataCA), conf.int=TRUE, main="Canada: Survival Model (Synthetic Obs)", xlab="Terms in Government", ylab="Survival Rate", col=c("black","red"))
legend(x=8,y=0.95,c("Backbencher","Cabinet"),col=c("black","red"),lty=1)
dev.off()
# Survival Model sans synth obs, Canada
pdf("survivalModelNZ.pdf")
plot(survfit(survivalModelNZ, newdata=survModelPlotDataNZ), conf.int=TRUE, main="NZ: Survival Model (No Synthetic Obs)", xlab="Terms in Government", ylab="Survival Rate", col=c("black","red"))
legend(x=8,y=0.95,c("Backbencher","Cabinet"),col=c("black","red"),lty=1)
dev.off()
# Survival Model with synth obs, Canada
pdf("combinedModelNZ.pdf")
plot(survfit(combinedModelNZ, newdata=survModelPlotDataNZ), conf.int=TRUE, main="NZ: Survival Model (Synthetic Obs)", xlab="Terms in Government", ylab="Survival Rate", col=c("black","red"))
legend(x=8,y=0.95,c("Backbencher","Cabinet"),col=c("black","red"),lty=1)
dev.off()
# Table 1: Cross-sectional models.
stargazer(crossSecModelCA, crossSecMartinCA, crossSecModelNZ, crossSecMartinNZ,
se=list(coeftest(crossSecModelCA, sandwich)[,2], coeftest(crossSecMartinCA, sandwich)[,2],
coeftest(crossSecModelNZ, sandwich)[,2], coeftest(crossSecMartinNZ, sandwich)[,2]),
title="Cross-Sectional OLS",ci=TRUE,out="model1.tex",
column.labels=c("CA Main", "CA Martin", "NZ Main", "NZ Martin"), column.separate=c(1,1),
notes=c("Additional party fixed effects suppresssed","CIs from Heteroskedasticity-robust standard error estimates"),
omit=c(".*B.Q.", ".*CA", ".*CCF", ".*N.D.P.", ".*Ref.",".*ACT",".*Alliance",".*GP",".*Mana",".*Maori",".*NL",".*NZF",".*Progressive",".*Social Credit",".*UFNZ"),
covariate.labels=c("Cabinet Now", "Cab. Important", "Prime Minister", "Party in Gov't", "Terms Served", "Incumbent", "Party In Gov't", "Conservative FE", "Liberal FE", "Progressive Cons. FE","Labour FE","National FE"),
no.space=TRUE, digits=2, omit.stat=c("f","rsq","res.dev","ser"),
table.placement = "!htb")
# Table 2: Control for past performance
stargazer(controlShareModelCA, firstDiffModelCA, martinFDModelCA,
controlShareModelNZ, firstDiffModelNZ, martinFDModelNZ,
se=list(coeftest(controlShareModelCA, sandwich)[,2],
coeftest(firstDiffModelCA, sandwich)[,2],
coeftest(martinFDModelCA, sandwich)[,2],
coeftest(controlShareModelNZ, sandwich)[,2],
coeftest(firstDiffModelNZ, sandwich)[,2],
coeftest(martinFDModelNZ, sandwich)[,2]),
dep.var.labels=c("VotePct", "$\\Delta$ VotePct", "VotePct", "$\\Delta$ VotePct"),
title="Past Performance Models",ci=TRUE,out="model2.tex",
column.labels=c("CA Control", "CA $\\Delta$", "CA Martin", "NZ Control", "NZ $\\Delta$", "NZ Martin"),
column.separate=c(1,1,1),
notes=c("Additional party fixed effects suppresssed","CIs from Heteroskedasticity-robust standard error estimates"),
omit=c(".*B.Q.", ".*CA", ".*CCF", ".*N.D.P.", ".*Ref.",".*ACT",".*Alliance",".*GP",".*Mana",".*Maori",".*NL",".*NZF",".*Progressive",".*Social Credit",".*UFNZ"),
covariate.labels=c("Cabinet Now", "Cab. Important", "Prime Minister", "Party in Gov't", "Terms Served", "Conservative FE", "Liberal FE", "Progressive Cons. FE","Labour FE", "National FE", "Prev. VotePct"),
no.space=TRUE, digits=2, omit.stat=c("f","rsq","res.dev","ser"),
table.placement = "!htb")
# Modal example for Canadian logit interpretation
# Modal example; how does the first-term incumbent Liberal do?
print(paste("Mean predicted probability for noncabinet example:", mean(predProb0CA)))
print(paste("CI for noncabinet example: ",quantile(predProb0CA, c(0.025, 0.975))))
print(paste("Mean predicted probability for cabinet example:",mean(predProb1CA)))
print(paste("CI for cabinet example: ",quantile(predProb1CA, c(0.025, 0.975))))
print(paste("Mean delta: ",mean(predProb1CA-predProb0CA)))
print(paste("CI for delta: ",quantile(predProb1CA-predProb0CA,c(0.025,0.975))))
# Table 3: Cross-Sectional Logits
stargazer(logitModelCA, logitMartinCA, logitModelNZ, logitMartinNZ, title="Cross-Sectional Logit",
out="model3.tex", column.labels=c("CA Main", "CA Martin", "NZ Main", "NZ Martin"), ci=TRUE,
column.separate=c(1,1, 1, 1), notes=c("Additional party fixed effects suppresssed","Estimates and CIs from 1000 nonparametric bootstrap samples"),
omit=c(".*B.Q.", ".*CA", ".*CCF", ".*N.D.P.", ".*Ref.",".*ACT",".*Alliance",".*GP",".*Mana",".*Maori",".*NL",".*NZF",".*Progressive",".*Social Credit",".*UFNZ"),
covariate.labels=c("Cabinet Now", "Cab. Important", "Prime Minister", "Party in Gov't", "Terms Served", "Incumbent", "Conservative FE", "Liberal FE", "Progressive Cons. FE", "Labour FE", "National FE"),
no.space=TRUE, digits=2, omit.stat=c("f","rsq","res.dev","ll","aic"),
coef=list(logitEstimatesCA, logitEstimatesMCA, logitEstimatesNZ, logitEstimatesMNZ),
ci.custom = list(CIsCA, CIsMCA, CIsNZ, CIsMNZ),
dep.var.labels=c("Pr(Elected)"),
table.placement = "!htb")
# This table is marginally too wide--I manually edit the .tex file to shrink it by 10%
# Table 4: Survival Model
ciMatrixSurvivalNZ[[1]][3,2] = 0.000
ciMatrixSurvivalNZ[[1]][12,2] = 0.000
# Stargazer will not properly plot the original data due to data errors in Prime Minister and a minor
# party fixed effect we suppress. I manually override these effects to 0. Essentially, no Prime Minister
# ever loses re-election in the dataset and so the model cannot meaningfully interpret the covariate.
stargazer(survivalModelCA, survivalModelNZ, title="Survival Analysis",
ci=TRUE,out="model4.tex",
column.labels=c("CA Survival", "NZ Survival"),
notes=c("Additional party fixed effects suppresssed"),
omit=c(".*B.Q.", ".*CA", ".*CCF", ".*N.D.P.", ".*Ref.",".*ACT",".*Alliance",".*GP",".*Mana",".*Maori",".*NL",".*NZF",".*Progressive",".*Social Credit",".*UFNZ"),
covariate.labels=c("Cabinet Now", "Cab. Important", "Prime Minister", "Party In Gov't", "Conservative FE", "Liberal FE", "Progressive Cons. FE", "Labour FE", "National FE"),
no.space=TRUE, digits=2,
omit.stat=c("rsq","ll", "wald", "lr", "max.rsq", "logrank"),
dep.var.labels=c("Survival Hazard", "Survival Hazard"),
coef=list(summary(survivalModelCA)$conf.int[,1], summary(survivalModelNZ)$conf.int[,1]),
ci.custom=list(ciMatrixSurvivalCA[[1]], ciMatrixSurvivalNZ[[1]]),
p=list(summary(survivalModelCA)$coefficients[,5], summary(survivalModelNZ)$coefficients[,5]),
column.separate=c(1,1),
table.placement = "!htb")
# Table 5: Survival Model with Synth Obs
stargazer(combinedModelCA, combinedModelNZ, title="Survival Analysis w/ Synthetic Obs",
ci=TRUE,out="model5.tex",
notes=c("Additional party fixed effects suppresssed"),
column.labels=c("CA Survival", "NZ Survival"),
omit=c(".*B.Q.", ".*CA", ".*CCF", ".*N.D.P.", ".*Ref.",".*ACT",".*Alliance",".*GP",".*Mana",".*Maori",".*NL",".*NZF",".*Progressive",".*Social Credit",".*UFNZ"),
covariate.labels=c("Cabinet Now", "Cab. Important", "Prime Minister", "Party In Gov't", "Conservative FE", "Liberal FE", "Progressive Cons. FE", "Labour FE", "National FE"),
no.space=TRUE, digits=2,
omit.stat=c("rsq","ll", "wald", "lr", "max.rsq", "logrank"),
dep.var.labels=c("Survival Hazard", "Survival Hazard"),
coef=list(summary(combinedModelCA)$conf.int[,1], summary(combinedModelNZ)$conf.int[,1]),
ci.custom=list(ciMatrixCombCA[[1]], ciMatrixCombNZ[[1]]),
p=list(summary(combinedModelCA)$coefficients[,5], summary(combinedModelNZ)$coefficients[,5]),
table.placement = "!htb")
# Appendix: Alternate specifications
print("Beginning Appendix generation. This may take up to 1-2 minutes.")
# This objects take some time to calculate and I want to run them outside stargazer to avoid crashing issues
ridingFE = coeftest(altSpec13CA,sandwich)
ridingFECoef = ridingFE[1:14,1]
ridingFEse = ridingFE[1:14,2]
ridingFEp = ridingFE[1:14, 4]
indFixEffect = coeftest(indFixEffectModelCA, sandwich)
indFixEffectCoef = indFixEffect[1:6,1]
indFixEffectse = indFixEffect[1:6,2]
indFixEffectp = indFixEffect[1:6,4]
##### Hack to make stargazer take non-standard model objects
# stargazer doesn't want to take the overrided coefficients for a few of the models
# so I create an LM with the same functional form as the model it's replacing, put
# that in stargazer, and then override data manually. This does not affect any
# presented results.
stargazerOverride = lm(VotePct ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed + as.factor(Party), data=CAdtSerious)
stargazerOverride2 = lm(VotePct ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed, data=CAdtSerious)
rownames(altSpec11CA) = names(altSpec13CA$coefficients[1:14])
####
# Alternate specifications, appendix 3.
stargazer(list(stargazerOverride, altSpec12CA, stargazerOverride, altSpec14CA, stargazerOverride2, altSpec31CA),
se=list(altSpec11CA[,2],
coeftest(altSpec12CA, sandwich)[,2],
ridingFEse,
coeftest(altSpec14CA, sandwich)[,2],
indFixEffectse,
summary(altSpec31CA)$coef[,2]),
coef=list(altSpec11CA[,1],
NULL,
ridingFECoef,
NULL,
indFixEffectCoef,
NULL),
p=list(altSpec11CA[,4],
NULL,
ridingFEp,
NULL,
indFixEffectCoef,
NULL),
dep.var.labels=c("VotePct", "Pr(Elected)"),
title="Alternate Specifications",ci=TRUE,out="appendix2.tex",
column.labels=c("Cluster SE", "Incumbent", "Riding FE", "Age OLS", "Ind. Fix Effect", "Age Logit"),
#column.separate=c(4,1,1),
notes=c("Additional party fixed effects suppresssed","OLS CIs from Heteroskedasticity-robust standard error estimates"),
omit=c(".*B.Q.", ".*CA", ".*CCF", ".*N.D.P.", ".*Ref.",".*ACT",".*Alliance",".*GP",".*Mana",".*Maori",".*NL",".*NZF",".*Progressive",".*Social Credit",".*UFNZ", "(ID)",".*as.factor(Riding)"),
covariate.labels=c("Cabinet Now", "Cab. Important", "Prime Minister", "Party in Gov't", "Terms Served", "Incumbent", "Age", "Conservative FE", "Liberal FE","P.C. FE"),
no.space=TRUE, digits=2, omit.stat=c("all"),
table.placement = "!h")
# Appendix 4, New Zealand logit pre/post mmp
stargazer(preMMP, postMMP, title="Cross-Sectional Logit (NZ)",
out="appendix4.tex", column.labels=c("Pre-MMP", "Post-MMP"), ci=TRUE,
column.separate=c(1,1, 1, 1), notes=c("Additional party fixed effects suppresssed"),
omit=c(".*B.Q.", ".*CA", ".*CCF", ".*N.D.P.", ".*Ref.",".*ACT",".*Alliance",".*GP",".*Mana",".*Maori",".*NL",".*NZF",".*Progressive",".*Social Credit",".*UFNZ"),
#covariate.labels=c("Cabinet Now", "Cab. Important", "Prime Minister", "Party in Gov't", "Terms Served", "Incumbent", "Conservative FE", "Liberal FE", "Progressive Cons. FE", "Labour FE", "National FE"),
no.space=TRUE, digits=2, omit.stat=c("f","rsq","res.dev","ll","aic"),
dep.var.labels=c("Pr(Elected)"),
table.placement = "!htb")
stargazer(preMMP, postMMP, title="Cross-Sectional Logit (NZ)",
out="appendix4.tex", column.labels=c("Pre-MMP", "Post-MMP"), ci=TRUE,
column.separate=c(1,1, 1, 1), notes=c("Additional party fixed effects suppresssed"),
omit=c(".*B.Q.", ".*CA", ".*CCF", ".*N.D.P.", ".*Ref.",".*ACT",".*Alliance",".*GP",".*Mana",".*Maori",".*NL",".*NZF",".*Progressive",".*Social Credit",".*UFNZ"),
covariate.labels=c("Cabinet Now", "Cab. Important", "Prime Minister", "Party in Gov't", "Terms Served", "Labour FE", "National FE"),
no.space=TRUE, digits=2, omit.stat=c("f","rsq","res.dev","ll","aic"),
dep.var.labels=c("Pr(Elected)"),
table.placement = "!htb")
rm(list=ls())
library(survival) # Survival modeling
library(stargazer) # Output tables
library(sandwich) # Robust SEs
library(lmtest) # Robust SEs
library(dplyr) # Data manipulation
library(car) # Diagnostics of regression
#setwd("~/Dropbox/Field Paper/")
# ENSURE THAT WORKING DIRECTORY IS SET PROPERLY TO ROOT OF FIELD PAPER
###### Support functions ####
secondHighest = function(x) # Code snippet from StackOverflow--used to get second highest of a list
{
sort(unique(x), decreasing=TRUE)[2L]
}
logitCoeffToPredictedProb = function(logitCoefs, values) # Convert series of logit coefficients and values to predicted prob.
{
sum = sum(logitCoefs*values)
expValue = exp(sum)
return(expValue / (1+expValue))
}
Mode <- function(x) { # Code snippet from StackOverflow. Mode.
ux <- unique(x)
ux[which.max(tabulate(match(x, ux)))]
}
# Implementation of clustered standard errors
# From: https://diffuseprior.wordpress.com/2012/06/15/standard-robust-and-clustered-standard-errors-computed-in-r/
olsClusteredStandardErrors <- function(form, data, robust=FALSE, cluster=NULL,digits=3){
r1 <- lm(form, data)
if(length(cluster)!=0){
data <- na.omit(data[,c(colnames(r1$model),cluster)])
r1 <- lm(form, data)
}
X <- model.matrix(r1)
n <- dim(X)[1]
k <- dim(X)[2]
if(robust==FALSE & length(cluster)==0){
se <- sqrt(diag(solve(crossprod(X)) * as.numeric(crossprod(resid(r1))/(n-k))))
res <- cbind(coef(r1),se)
}
if(robust==TRUE){
u <- matrix(resid(r1))
meat1 <- t(X) %*% diag(diag(crossprod(t(u)))) %*% X
dfc <- n/(n-k)
se <- sqrt(dfc*diag(solve(crossprod(X)) %*% meat1 %*% solve(crossprod(X))))
res <- cbind(coef(r1),se)
}
if(length(cluster)!=0){
clus <- cbind(X,data[,cluster],resid(r1))
colnames(clus)[(dim(clus)[2]-1):dim(clus)[2]] <- c(cluster,"resid")
m <- dim(table(clus[,cluster]))
dfc <- (m/(m-1))*((n-1)/(n-k))
uclust  <- apply(resid(r1)*X,2, function(x) tapply(x, clus[,cluster], sum))
se <- sqrt(diag(solve(crossprod(X)) %*% (t(uclust) %*% uclust) %*% solve(crossprod(X)))*dfc)
res <- cbind(coef(r1),se)
}
res <- cbind(res,res[,1]/res[,2],(1-pnorm(abs(res[,1]/res[,2])))*2)
res1 <- matrix(as.numeric(sprintf(paste("%.",paste(digits,"f",sep=""),sep=""),res)),nrow=dim(res)[1])
rownames(res1) <- rownames(res)
colnames(res1) <- c("Estimate","Std. Error","t value","Pr(>|t|)")
return(res1)
}
#### End support functions
############## PREP DATA #############
# Read the election data
dataT = read.csv("~/Dropbox/Field Paper/Canada Data/Merge/output.csv", header=TRUE)
# Discard data before 1945 general election
dataT = dataT[as.character(dataT$Date)>="1945-06-11",]
# Code party in government
dataT$PartyInGovt = 0
dataT[as.character(dataT$Date)>="1935-01-01" & as.character(dataT$Date)<="1948-11-14" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1948-11-15" & as.character(dataT$Date)<="1957-06-20" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1957-06-21" & as.character(dataT$Date)<="1963-04-21" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1963-04-22" & as.character(dataT$Date)<="1968-04-19" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1968-04-20" & as.character(dataT$Date)<="1979-06-02" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1979-06-02" & as.character(dataT$Date)<="1980-03-01" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1980-03-02" & as.character(dataT$Date)<="1984-09-15" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1984-09-17" & as.character(dataT$Date)<="1993-11-02" & dataT$Party=="P.C.",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="1993-11-03" & as.character(dataT$Date)<="2006-02-05" & dataT$Party=="Lib",]$PartyInGovt = 1
dataT[as.character(dataT$Date)>="2006-02-06" & dataT$Party=="C",]$PartyInGovt = 1
# Recode party labels to only include major parties and other; no substantive reason to keep variation in that regard.
dataT[dataT$Party!="Lib" & dataT$Party!="P.C." & dataT$Party!="C" & dataT$Party!="CA" & dataT$Party!="N.D.P." & dataT$Party!="Ref." & dataT$Party!="CCF" & dataT$Party!="B.Q.",]$Party = "Ind."
dataT$Party = relevel(dataT$Party, "Ind.")
dataT = dataT[dataT$Votes>-1,]
crossSecModelCA = lm(VotePct ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed + as.factor(Party), data=dataT)
crossSecMartinCA = lm(VotePct ~ CabinetNow + Incumbent + as.factor(Party), data=dataT)
summary(crossSecModelCA)
summary(crossSecMartinCA)
prevCandidates = dataT[dataT$LastVotes>0 & dataT$Incumbent==1,]
# Code y_t,i - y_{t-1},i
prevCandidates$FDVotePct = prevCandidates$VotePct - prevCandidates$LastVotePct
firstDiffModelCA = lm(FDVotePct ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed + as.factor(Party), data=prevCandidates)
summary(firstDiffModelCA)
controlShareModelCA = lm(VotePct ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed + as.factor(Party) + LastVotePct, data=prevCandidates)
summary(controlShareModelCA)
indFixEffectModelCA = lm(VotePct ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed + as.factor(ID), data=prevCandidates)
summary(indFixEffectModelCA)
summary(indFixEffectModelCA)$coefficients[1:14,]
logitModelCA = glm(Elected ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + TermsServed + as.factor(Party), family=binomial(link=logit), data=dataT)
logitMartinCA = glm(Elected ~ CabinetNow + Incumbent + as.factor(Party), family=binomial(link=logit), data=dataT)
summary(logitMartinCA)
summary(logitModelCA)
survivalSubset = dataT[dataT$Incumbent==1,c("ID","Name","Incumbent","TermsServed","CabinetNow","CabinetImportant","CabinetPM","Date","Elected","Party", "PartyInGovt")]
# Whip data into spells
survivalDataCA = survivalSubset %>% mutate(start=TermsServed-1, end=TermsServed, death=as.integer(!Elected==1), pName=as.character(Party)) %>% select(ID, start, end, death, CabinetNow, CabinetImportant, CabinetPM, PartyInGovt, pName)
survivalDataCA$pName = as.factor(survivalDataCA$pName)
survivalDataCA$pName = relevel(survivalDataCA$pName, "Ind.")
# Setup survival DV
survivalDVCA = Surv(survivalDataCA$start, survivalDataCA$end, survivalDataCA$death)
# And the model
survivalModelCA = coxph(survivalDVCA ~ CabinetNow + CabinetImportant + CabinetPM + PartyInGovt + pName, data=survivalDataCA)
summary(survivalModelCA)
